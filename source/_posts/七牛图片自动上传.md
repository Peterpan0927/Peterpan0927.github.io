---
title: 七牛图片自动上传
date: 2017-06-15 09:38:36
tags: 中文编码解决 
categories: 输出markdown格式的图片链接
---

qiniu4blog自动上传
<!--more-->
## 源码部分

```python
  1 #!/usr/bin/env python
  2 # -*- coding: utf-8 -*-
  3 import os, time, sys, ConfigParser, platform, urllib, qiniu, pyperclip, signal, threading
  4 from mimetypes import MimeTypes
  5 from os.path import expanduser
  6 from watchdog.observers import Observer
  7 from watchdog.events import PatternMatchingEventHandler
  8
  9
 10 # 使用watchdog 监控文件夹中的图像
 11 class MyHandler(PatternMatchingEventHandler):
 12     patterns = ["*.jpeg", "*.jpg", "*.png", "*.bmp", "*.gif","*.tiff"]
 13     ignore_directories = True
 14     case_sensitive = False
 15     def process(self, event):
 16         if event.event_type == 'created'or event.event_type == 'modified': #如果是新增文件或修改的文件
 17             myThread(event.src_path, 1).start() # 开启线程
 18     def on_modified(self, event):
 19         self.process(event)
 20     def on_created(self, event):
 21         self.process(event)

 24 # 使用多线程上传
 25 class myThread(threading.Thread):
 26     def __init__(self, filePath, mode): #filePath 文件路径 和 上传模式
 27         threading.Thread.__init__(self)
 28         self.filePath = filePath
 29         self.mode = mode
 30     def run(self):
 31         threadLock.acquire()
 32         job(self.filePath, self.mode)
 33         threadLock.release()
 34
 35
 36 # 上传图像、复制到粘贴板、写到文件
 37 def job(file, mode):
 38     if mode == 1:
 39         url = upload_with_full_Path(file)
 40     if mode == 2:
 41         url = upload_with_full_Path_cmd(file)
 42     pyperclip.copy(url)
 43     pyperclip.paste()
 44     print url
 45     with open('MARKDOWN_FORMAT_URLS.txt', 'a') as f:
 46         image = '![' + url + ']' + '(' + url + ')' + '\n'
 47         f.write(image + '\n')
 48
 49 #-----------------配置--------------------
 50 homedir = expanduser("~")  # 获取用户主目录
 51 config = ConfigParser.RawConfigParser()
 52 config.read(homedir + '/qiniu.cfg')  # 读取配置文件
 53 mime = MimeTypes()
 54 threadLock = threading.Lock()
 55
 56
 57 # 优雅退出
 58 def exit_gracefully(signum, frame):
 59     signal.signal(signal.SIGINT, original_sigint)
 60     try:
 61         if raw_input("\nReally quit? (y/n)> ").lower().startswith('y'):
 62             sys.exit(1)
 63     except KeyboardInterrupt:
 64         print("Ok ok, quitting")
 65         sys.exit(1)
 66     signal.signal(signal.SIGINT, exit_gracefully)
 67
 68 original_sigint = signal.getsignal(signal.SIGINT)
 69 signal.signal(signal.SIGINT, exit_gracefully)
 70
 71 try:
 72     bucket = config.get('config', 'bucket')  # 设置  bucket
 73     accessKey = config.get('config', 'accessKey')  # 设置  accessKey
 74     secretKey = config.get('config', 'secretKey')  # 设置  secretKey
 75     path_to_watch = config.get('config', 'path_to_watch')  # 设置   监控文件夹
 76     enable = config.get('custom_url', 'enable')  # 设置自定义使能 custom_url
 77     if enable == 'false':
 78         print 'custom_url not set'
 79     else:
 80         addr = config.get('custom_url', 'addr')
 81 except ConfigParser.NoSectionError, err:
 82     print 'Error Config File:', err
 83
 84
 85 # 设置编码
 86 def setCodeingByOS():
 87     if 'cygwin' in platform.system().lower():
 88         return 'GBK'
 89     elif os.name == 'nt' or platform.system() == 'Windows':
 90         return 'GBK'
 91     elif os.name == 'mac' or platform.system() == 'Darwin':
 92         return 'utf-8'
 93     elif os.name == 'posix' or platform.system() == 'Linux':
 94         return 'utf-8'
 95
 96
 97 # 处理七牛返回结果
 98 def parseRet(retData, respInfo):
 99     if retData != None:
100         for k, v in retData.items():
101             if k[:2] == "x:":
102                 print(k + ":" + v)
103         for k, v in retData.items():
104             if k[:2] == "x:" or k == "hash" or k == "key":
105                 continue
106             else:
107                 print(k + ":" + str(v))
108     else:
109         print("Upload file failed!")
110
111 # 上传文件方式 1
112 def upload_without_key(bucket, filePath, uploadname):
113     auth = qiniu.Auth(accessKey, secretKey)
114     upToken = auth.upload_token(bucket, key=None)
115     key = uploadname
116     retData, respInfo = qiniu.put_file(upToken, key, filePath, mime_type=mime.guess_type(filePath)[0])
117     parseRet(retData, respInfo)
118
119
120 # 上传文件方式 2
121 def upload_with_full_Path(filePath):
122     if platform.system() == 'Windows':
123         fileName = "/".join("".join(filePath.rsplit(path_to_watch))[1:].split("\\"))
124     else:
125         fileName = "".join(filePath.rsplit(path_to_watch))[1:]
126     upload_without_key(bucket, filePath, fileName.decode(setCodeingByOS()))
127     if enable == 'true':
128         return '!['+fileName+']('+addr + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))+')'
129     else:
130         return 'http://' + bucket + '.qiniudn.com/' + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))
131
132
133 # 上传文件方式 3
134 def upload_with_full_Path_cmd(filePath):
135     if platform.system() == 'Windows':
136         fileName = os.path.basename("/".join((filePath.split("\\"))))
137     else:
138        fileName = os.path.basename(filePath)
139     upload_without_key(bucket, filePath, fileName.decode(setCodeingByOS()))
140     if enable == 'true':
141         return addr + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))
142     else:
143         return 'http://' + bucket + '.qiniudn.com/' + urllib.quote(fileName.decode(setCodeingByOS()).encode('utf-8'))
144
145 #-----------------window platform---------------start
146 # window下的监控文件夹变动方式-获取所有文件路径
147 def get_filepaths(directory):
148     file_paths = []  # List which will store all of the full filepaths.
149     for root, directories, files in os.walk(directory):
150         for filename in files:
151             # Join the two strings in order to form the full filepath.
152             filepath = os.path.join(root, filename)
153             file_paths.append(filepath)  # Add it to the list.
154     return file_paths  # Self-explanatory.
155
156 def set_clipboard(url_list,fileName):
157     for url in url_list:
158   image = '!['+fileName+']' + '(' + url + ')' + '\n'
159         pyperclip.copy(url)
160     spam = pyperclip.paste()
161
162 def get_filename(url):
163     return url.split("/")[-1:][0].split('.')[0]
164
165 def window_main():
166     if len(sys.argv) > 1:
167         url_list = []
168         for i in sys.argv[1:]:
169             url_list.append(upload_with_full_Path_cmd(i))
170         with open('MARKDOWN_FORMAT_URLS.txt', 'a') as f:
171             for url in url_list:
172                 image = '![' + url + ']' + '(' + url + ')' + '\n'
173                 print url, '\n'
174                 f.write(image)
175         print "\nNOTE: THE MARKDOWN FORMAT URLS ALREADY SAVED IN MARKDOWN_FORMAT_URLS.txt FILE"
176         set_clipboard(url_list)
177         sys.exit(-1)
178     print "running ... ... \nPress Ctr+C to Stop"
179     before = get_filepaths(path_to_watch)
180     while 1:
181         time.sleep(1)
182         after = get_filepaths(path_to_watch)
183         added = [f for f in after if not f in before]
184         removed = [f for f in before if not f in after]
185         if added:
186             url_list = []
187             for i in added:
188                 url_list.append(upload_with_full_Path(i))
189             with open('MARKDOWN_FORMAT_URLS.txt', 'a') as f:
190                 for url in url_list:
191                     image = '![' + url + ']' + '(' + url + ')' + '\n'
192                     print url, '\n'
193                     f.write(image)
194             print "\nNOTE: THE MARKDOWN FORMAT URLS ALREADY SAVED IN MARKDOWN_FORMAT_URLS.txt FILE"
195             set_clipboard(url_list)
196         if removed:
197             pass
198         before = after
199
200
201 def unix_main():
202     if len(sys.argv) > 1:
203         url_list = []
204         for i in sys.argv[1:]:
205             url_list.append(upload_with_full_Path_cmd(i))
206             fileFullName = os.path.basename("/".join((i.split("\\"))))
207             fileName = os.path.splitext(fileFullName)[0]
208             myThread(i, 2).start()
209         with open('markdownIMG.txt', 'a') as f:
210             for url in url_list:
211                 image = '!['+fileName+']' + '(' + url + ')' + '\n'
212                 print 'Url:'+image, '\nFileName:'+fileFullName
213                 f.write(image)
214     set_clipboard(url_list,fileName)
215         sys.exit(-1)
216     print "running ... ... \nPress Ctr+C to Stop"
217     observer = Observer()
218     observer.schedule(MyHandler(), path=path_to_watch if path_to_watch else '.', recursive=True)
219     observer.start()
220     before = get_filepaths(path_to_watch)
221     while 1:
222         time.sleep(1)
223         after = get_filepaths(path_to_watch)
224         added = [f for f in after if not f in before]
225         removed = [f for f in before if not f in after]
226         if added:
227             url_list = []
228             for i in added:
229                 url_list.append(upload_with_full_Path(i))
230                 fileFullName = os.path.basename("/".join((i.split("\\"))))
231                 fileName = os.path.splitext(fileFullName)[0]
232       with open('MARKDOWN_FORMAT_URLS.txt', 'a') as f:
233                 for url in url_list:
234                     image = '![' + url + ']' + '(' + url + ')' + '\n'
235                     print url, '\n'
236                     f.write(image)
237             print "\nNOTE: THE MARKDOWN FORMAT URLS ALREADY SAVED IN MARKDOWN_FORMAT_URLS.txt FILE"
238            # set_clipboard(url_list,fileName)
239         if removed:
240             pass
241         before = after
242     try:
243         while True:
244             time.sleep(0.1)
245     except KeyboardInterrupt:
246         observer.stop()
247     observer.join()
248
249 def main():
250     if os.name == 'nt' or platform.system() == 'Windows':
251         window_main()  #window 下执行
252     else:
253         unix_main()   #mac 下执行
254
255 if __name__ == "__main__":
256     main()
```


## 修改python2的默认编码

python2的默认编码是ascii,当程序中出现非ascii编码时，python的处理常常会报这样的错:

UnicodeDecodeError: 'ascii' codec can't decode byte 0x?? in position 1: ordinal not in range(128)

python没办法处理非ascii编码的，此时需要自己设置将python的默认编码，一般设置为utf8的编码格式。

解决方案：在路径`/Library/Python/2.7/site-packages`下新建一个sitecustomize.py，内容为：

```python
# encoding=utf8  
import sys  
  
reload(sys)  
sys.setdefaultencoding('utf8')  
```

这个时候重启python解释器，执行sys.getdefaultencoding()，会发现此时的默认编码已经转换成utf-8了，多次重启之后，效果相同，这是因为系统在python启动的时候，自行调用该文件，设置系统的默认编码，而不需要每次都手动的加上解决代码，属于一劳永逸的解决方法。