---
title: Linux进程
author: Peterpan
date: 2017-05-22 17:29:17
tags: Linux内核
categories: 系统调用 内核空间 用户空间
---

Linux进程
<!--more-->

# Linux进程

进程是Unix操作系统抽象概念中最基本的一种，因此进程管理就是所有操作系统的心脏所在，Linux也不意外

## 进程：

就是处于执行期中的程序，但不仅仅局限在一段可执行的程序代码（Unix中称之为代码段），通常进程还要包括其他资源，进程还包括了打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间，存放全局变量的数据段，一个或执行多个线程。

## 线程：

执行线程，简称线程，是在进程中的活动对象。每个线程都有一个独立的程序计数器，进程栈和一组进程寄存器。内核调度的对象是线程而不是进程。传统的Unix系统中，一个进程只包含一个线程，现在的系统中包含多个线程的多线程程序司空见惯，而Linux中线程的实现比较特别，它对进程和线程并不特别区分，线程只不过是一种特殊的进程。

## 1.进程的创建

在Linux系统中通常是通过[fork()](http://blog.csdn.net/jason314/article/details/5640969)系统调用复制一个现有的进程来创造一个全新的进程(现代Linux内核中，fork()实际上是有clone系统调用实现的)。调用fork()的进程被称作父进程，产生的进程称作子进程。

子进程是父进程的**副本**，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间**不共享**这些存储空间，**子进程有了独立的地址空间**。

在该调用结束的时候，在返回点这个相同的位置上，父进程恢复执行，子进程开始执行。fork()系统调用从内核中返回两次：一次回到父进程，另一次回到新产生的子进程。

创建子进程，fork()函数返回两个数值，若创建成功，子进程中返回0；父进程返回子进程ID。用资源空间图示如下：

![DACF16C2-9CA7-436A-B811-D6F36ACC4F1B](http://omunhj2f1.bkt.clouddn.com/DACF16C2-9CA7-436A-B811-D6F36ACC4F1B.png)

代码执行解释：

![82A0E7D9-73C9-4BB0-9BF9-161AD547FD56](http://omunhj2f1.bkt.clouddn.com/82A0E7D9-73C9-4BB0-9BF9-161AD547FD56.png)

由操作系统相关知识可知，**进程是系统资源分配的基本单位，**因此子进程与父进程不共享进程资源空间。在执行代码段第8行之前，系统中只有默认的主进程。在执行完代码段第8行后，系统中就有了两个进程，即主进程和由其创建的子进程。所以代码执行在打印的时候只有一个"Before the fork()…"，而有两个"After the fork()..."

执行了fork()函数后，主进程为父进程生成了一份资源空间的副本。主进程中的pid为子进程的pid(pid>0)，子进程中的pid为0。

在fork()函数之后父进程与子进程都从下一行执行，即第9行。因为主进程中pid>0，可以执行else if(pid>0)段代码，子进程pid=0，可以执行else if(pid==0)段代码。

 fork出错可能有两种原因：
​    1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
​    2）系统内存不足，这时errno的值被设置为ENOMEM。  

执行的结果：

```c
Before the fork(), pid = 9715
After the fork(), pid = 9715
the parent process! 9715
After the fork(), pid = 9716
the chlid process! 9716
```

具体的执行结果，可能会由于进程调度的不同，后面的四个输出顺序可能不同。不过第一个输出的一定是"Before the fork ..."

最终，程序通过exit()系统调用退出执行。这个函数会终结进程并将其占用的资源给释放掉。父进程可以通过wait4()系统调用来查询子进程是否被终结，这其实使得进程拥有了等待特定进程执行完毕的能力。进程退出执行后被设置为僵死状态，直到它的父进程调用wait()或者waitpid()为止。

## 2.进程描述符和任务结构

#### 1.进程描述符

内核把进程的列表存放在叫做"任务队列"(task list)的双向循环链表中。链表中的每一项都是类型为task_struct，称为进程描述符的结构。进程描述符包含一个进程的所有信息。

task_struct中包含的数据能够完整的描述一个正在执行的程序：它打开的文件，进程的地址空间，进程的状态，挂起的信号等等

![](http://omunhj2f1.bkt.clouddn.com/48840FF2-338D-4B87-A792-862B476EF114.png)

Linux通过slab分配器分配task_struct结构，这样可以达到对象复用和缓存着色的目的，由于slab分配器动态生成task_struct，所以只需要在栈底（对于向下生长的栈）或者栈顶（对于向上生长的栈）创建一个新的结构struct thread_info

![132CC7AF-8C03-4506-A99E-B6C5AE0559E6](http://omunhj2f1.bkt.clouddn.com/132CC7AF-8C03-4506-A99E-B6C5AE0559E6.png)

![EBC98897-3BCD-4B27-92C0-889C0CFC9FF1](http://omunhj2f1.bkt.clouddn.com/EBC98897-3BCD-4B27-92C0-889C0CFC9FF1.png)

每个任务的thread_info结构在它的内核栈的尾端分配。结构中的task域中存放的是指向task_struct的指针。

内核通过一个唯一的进程标识值或者PID来标识每个进程。PID是一个数，实际上就是一个int型。为了和老版Unix和Linux兼容，PID的最大值默认设置为32768（short int短整型的最大值），内核把每个PID存放在他们各自的进程描述符中。

新创建的进程的PID通常是前一个进程的PID+1，PID并非无限向上增长。PID有一个最大值上限，当超过了这个上限后，PID就开始循环使用已闲置的小PID号（循环的起点PID号根据不同操作系统而不同）。

系统管理员可以通过往`/proc/sys/kernel/pid_max`这个特殊文件写入一个更小的值来减小PID上限。64位系统PID最大值可以扩展到4194303。

在各PID中，较为特别的是0号PID和1号PID。PID为0者为交换进程，属于内核进程，负责[分页](https://zh.wikipedia.org/wiki/%E5%88%86%E9%A1%B5)任务；PID为1者则常为[init](https://zh.wikipedia.org/wiki/Init)进程，主要负责启动与关闭系统。值得一提的是，1号PID本来并非是特意为init进程预留的，而init进程之所以拥有这一PID，则是因为init即是内核创建的第一个进程。

在内核中，访问任务通常需要获得指向其task_struct的指针。实际上，内核中大部分处理进程的代码都是直接通过task_struct进行的，所以通过[current宏](http://www.cnblogs.com/cherishui/p/4255690.html)查找到当前正在运行的进程的进程描述符的速度就尤为重要。硬件体系结构不同，该宏的实现也不同。有的硬件体系结构专门拿出一个寄存器来存放task_struct的指针，用于加快访问的速度。而有些像x86这样寄存器并不富余的，就只能在内核栈的尾端创建thread_info结构，通过计算偏移间接查找task_struct结构。

#### 2.进程状态：

进程描述符中的state域描述了当前进程的当前状态。系统中的每个进程 都必然处于几种进程状态中的一种，该域的值也必为下列几种状态中的一种：

通过`ps aux`可以看到进程的状态。

O：进程正在处理器运行,这个状态从来没有见过. 
S：休眠状态（sleeping） 
R：等待运行（runable）R Running or runnable (on run queue) 进程处于运行或就绪状态 
I：空闲状态（idle） 
Z：僵尸状态（zombie） 
T：跟踪状态（Traced） 
B：进程正在等待更多的内存页 
D: 不可中断的深度睡眠，一般由IO引起，同步IO在做读或写操作时，cpu不能做其它事情，只能等待，这时进程处于这种状态，如果程序采用异步IO，这种状态应该就很少见到了

其中就绪状态表示进程已经分配到除CPU以外的资源，等CPU调度它时就可以马上执行了。运行状态就是正在运行了，获得包括CPU在内的所有资源。等待状态表示因等待某个事件而没有被执行，这时候不耗CPU时间，而这个时间有可能是等待IO、申请不到足够的缓冲区或者在等待信号。下面是一个关系图

![918777F0-F802-49CD-9B45-5AA56CDBC383](http://omunhj2f1.bkt.clouddn.com/918777F0-F802-49CD-9B45-5AA56CDBC383.png)

内核中经常需要设置当前进程的状态。这时最好用set_task_state(task,state)函数：

```c
set_task_state(task, state);         /*将任务task的状态设置为state*/
```

该函数将指定的进程指定为指定的状态，必要的时候，他会设置内存屏障来强制其他处理器作重新排序（一般只有在对称多处理机制系统下才有这个必要）否则它等价于：

```c
task->state = state;
```

#### 上下文的概念

 内核空间和用户空间是现代[操作系统](http://lib.csdn.net/base/operatingsystem)的两种工作模式，内核模块运行在内核空间，而用户态应用程序运行在用户空间。它们代表不同的级别，而对系统资源具有不同的访问权限。内核模块运行在最高级别（内核态），这个级下所有的操作都受系统信任，而应用程序运行在较低级别（用户态）。在这个级别，处理器控制着对硬件的直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即自己的地址空间。

​         其中处理器总处于以下状态中的一种：

​        **内核态**，运行于**进程上下文**，内核代表进程运行于内核空间；

​        **内核态**，运行于**中断上下文**，内核代表硬件运行于内核空间；

​        **用户态**，运行于用户空间。

　　系统的两种不同运行状态，才有了上下文的概念。用户空间的应用程序，如果想请求系统服务，比如操作某个物理设备，映射设备的地址到用户空间，必须通过系统调用来实现。（系统调用是操作系统提供给用户空间的接口函数）。

​       通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的 地址映射，通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户 空间继续执行，

#### 进程上下文

可执行代码是进程的重要组成部分，这些代码从一个可执行文件载入到进程的地址空间去执行。一般程序在用户空间执行。当一个程序执行了系统调用或者触发了某个异常，他就陷入内核空间。此时，我们称内核"代表进程执行"并处于进程上下文中。除非此间隙有更高优先级的进程需要执行并由调度器作出相关调整，否则在内核退出的时候，程序恢复在用户空间会继续执行。

系统调用和异常处理程序是对内核明确的接口。进程只有通过这些接口才能陷入内核执行——对于内核的所有访问度必须通过这些接口。

所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它 需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。

  一个进程的上下文可以分为三个部分:**用户级上下文**、**寄存器上下文**以及**系统级上下文**。

​       1）用户级上下文: 正文、数据、用户堆栈以及共享存储区；

​       2）寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；

​       3）系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

当发生进程调度的时候，进行进程切换就是上下文切换

操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而**系统调用进行的是模式切换(mode switch)**。模式切换与进程切换比较起来，容易很多，而且节省时间，因为**模式切换最主要的任务只是切换进程寄存器上下文的切换**。

 进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态等。所以在进程上下文中引用current是有意义的。

#### 进程家族树

Unix系统的进程之间存在着一个明显的继承关系，在Linux系统中也会如此。所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本（initscript）并执行其他的相关程序，最后完成系统启动的整个过程。

系统的每一个进程都有一个父进程，相应的，每个进程也可以有0个或多个子进程。拥有同一个父进程的所有进程被称作兄弟，进程之间的关系存放在进程描述符中。每个task_struct中包含一个指向它父进程的task_struct叫做parent的指针，还包含一个称作children的子进程链表。所以，对于当前进程，可以通过下面的代码获得其父进程的进程描述符：

```c
struct task_struct   *my_parent = current->parent;
//同样，也可以按照下面的方式依次访问子进程
struct task_struct *task;
struct list_head *list;

list_for_each(list, &current->children) {
  task = list_entry(list, struct task_struct, sibling);
  /*task指向当前的某个子进程*/
}
```

init进程描述符是作为init_task静态分配的。下面的代码可以很好的演示所有进程之间的关系

```c
struct task_struct *task;
for ( task = current ; task != &init_task ; task = task->parent )
/*task现在指向init*／
```

实际上，你可以通过这种继承体系从系统的任何一个进程出发查找到任意指定的其他进程。但大多数时候，只需要通过简单的重复方式就可以遍历系统中的所有进程。这非常容易做到，因为任务队列本来就是一个双向的循环链表。对于给定的进程，获取链表的下一个进程：

```c
list_entry(task->tasks.next, struct task_struct, tasks)
//获取前一个进程的方法与之相同
list_entry(task->tasks.prev, struct task_struct, tasks)
```

注意⚠️：在一个拥有大量进程的系统中通过重复来遍历所有进程的代价很大，所以没有必要的话不要这样做。